%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Programming/Coding Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing assignment content.
%
% This template uses a Perl script as an example snippet of code, most other
% languages are also usable. Configure them in the "CODE INCLUSION 
% CONFIGURATION" section.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{array}



\usepackage[T1]{fontenc}
%\usepackage{polski}
\usepackage[utf8]{inputenc}

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
%\lhead{\hmwkAuthorName} % Top left header
\chead{\hmwkTitle} % Top center head
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Strona \thepage\ z\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	CODE INCLUSION CONFIGURATION
%----------------------------------------------------------------------------------------

\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
%\lstloadlanguages{Perl} % Load Perl syntax for listings, for a list of other languages supported see: ftp://ftp.tex.ac.uk/tex-archive/macros/latex/contrib/listings/listings.pdf
\lstset{language=C, % Use Perl in this example
        frame=single, % Single frame around code
        basicstyle=\small\ttfamily, % Use small true type font
        keywordstyle=[1]\color{Blue}\bf, % Perl functions bold and blue
        keywordstyle=[2]\color{Purple}, % Perl function arguments purple
        keywordstyle=[3]\color{Blue}\underbar, % Custom functions underlined and blue
        identifierstyle=, % Nothing special about identifiers                                         
        commentstyle=\usefont{T1}{pcr}{m}{sl}\color{MyDarkGreen}\small, % Comments small dark green courier font
        stringstyle=\color{Purple}, % Strings are purple
        showstringspaces=false, % Don't put marks in string spaces
        tabsize=5, % 5 spaces per tab
        %
        % Put standard Perl functions not included in the default language here
        morekeywords={rand},
        %
        % Put Perl function parameters here
        morekeywords=[2]{on, off, interp},
        %
        % Put user defined functions here
        morekeywords=[3]{test},
       	%
        morecomment=[l][\color{Blue}]{...}, % Line continuation (...) like blue comment
        numbers=left, % Line numbers on left
        firstnumber=1, % Line numbers start with line 1
        numberstyle=\tiny\color{Blue}, % Line numbers are blue and small
        stepnumber=5 % Line numbers go in steps of 5
}

% Creates a new command to include a perl script, the first parameter is the filename of the script (without .pl), the second parameter is the caption
\newcommand{\perlscript}[2]{
\begin{itemize}
\item[]\lstinputlisting[caption=#2,label=#1]{#1.pl}
\end{itemize}
}


\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

%----------------------------------------------------------------------------------------
%	DOCUMENT STRUCTURE COMMANDS
%	Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{

}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]{ % Makes a new environment called homeworkProblem which takes 1 argument (custom name) but the default is "Problem #"
\stepcounter{homeworkProblemCounter} % Increase counter for number of problems
\renewcommand{\homeworkProblemName}{#1} % Assign \homeworkProblemName the name of the problem
\section{\homeworkProblemName} % Make a section in the document with the custom problem count
\enterProblemHeader{\homeworkProblemName} % Header and footer within the environment
}{
\exitProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}} % Makes the box around the problem answer and puts the content inside
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{ % New environment for sections within homework problems, takes 1 argument - the name of the section
\renewcommand{\homeworkSectionName}{#1} % Assign \homeworkSectionName to the name of the section from the environment argument
\subsection{\homeworkSectionName} % Make a subsection with the custom name of the subsection
\enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]} % Header and footer within the environment
}{
\enterProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Problem komiwojażera w obecności ulic jednokierunkowych.} % Assignment title
\newcommand{\hmwkDueDate}{09 listopada 2016} % Due date
\newcommand{\hmwkAuthorName}{Marek Gumiński, Michał Gąska} % Your name

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\renewcommand{\tablename}{Tabela}


\title{
\vspace{2in}
\textmd{\textbf{\hmwkTitle}}\\
\normalsize\vspace{0.1in}\small{Wykonane\ \hmwkDueDate}\\
\vspace{0.1in}
\vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

\newpage
\tableofcontents
\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 1
%----------------------------------------------------------------------------------------

% To have just one problem per page, simply put a \clearpage after each problem
\section{Opis projektu}

Należy zaimplementować (nietrywialny) algorytm rozwiązujący problem komiwojażera, a następnie zbadać, czy można modelować ulice jednokierunkowe w ten sposób, że połączeniu w kierunku A->B (A, B - wybrane miasta) nadaje się wagę równą odległości miedzy miastami, a połączeniu B->A nadaje się wagę o bardzo dużej wartości. Głównym celem zadania jest identyfikacja warunków, w których algorytm wskazuje drogę „pod prąd” pomimo istnienia drogi „legalnej”. Literatura : Z. Michalewicz, D. B. Fogel, Jak to rozwiązać czyli nowoczesna heurystyka, WNT, Warszawa 2006
	
\section{Sprawozdanie 1}

Problem komiwojażera - zagadnienie optymalizacyjne, polegające na znalezieniu minimalnego cyklu Hamiltona w pełnym grafie ważonym.

asdfa

Nazwa pochodzi od typowej ilustracji problemu, przedstawiającej go z punktu widzenia wędrownego sprzedawcy (komiwojażera): dane jest n miast, które komiwojażer ma odwiedzić, oraz odległość/cena podróży/czas podróży pomiędzy każdą parą miast. Celem jest znalezienie najkrótszej/najtańszej/najszybszej drogi łączącej wszystkie miasta, zaczynającej się i kończącej się w określonym punkcie.
\\

W ramach projektu skupimy się na przetestowaniu działania algorytmu realizującego rozwiązanie problemu komiwojażera. Typowe algorytmy nie przewidują istnienia ulic jednokierunkowych, dlatego będą one symulowane poprzez wprowadzenie ścieżek o bardzo dużym koszcie.
\\

Testy pokarzą jak duże wagi należy nadać, aby algorytm nie stosował dróg pod prąd oraz jak wiele dróg jednokierunkowych można wprowadzić.
\\

Projekt zrealizujemy w języku Python. Rozważamy przetestowanie jednej z otwartych implementacji dostępnych w internecie.

\section{Sprawozdanie 2}

\subsection{Wybór algorytmu}
Realizację projektu zdecydowaliśmy się rozpocząć od wyboru algorytmu rozwiązującego problem komiwojażera.

Na podstawie analizy wydajności dokonanej w artykule [1] zdecydowaliśmy wykorzystać algorytm 2-opt (tabela 1 zawiera wyniki porównanie dokonanego we wspominanym artykule). Wybór podyktowany jest prostotą implementacji oraz rezultatami wyraźnie lepszymi niż algorytm zachłanny. We wspomnianej publikacji porównano algorytm zachłanny oraz 2-opt w obecności 30, 100 oraz 500 miast.  \\


\begin{table}[!h]
\centering
\caption{Porównanie długości cyklu Hamiltona wyznaczonego przez różne algorytmy.}
\label{my-label}
\begin{tabular}{|l|l|l|l|}
	\hline
						 & \textbf{30}   & \textbf{100}  & \textbf{500}   \\ \hline
	\textbf{Zachłanny}             & 2330 & 4478 & 10402 \\ \hline
	\textbf{2-opt}                 & 2095 & 4320 & 10083 \\ \hline
\end{tabular}
\end{table}

\subsection{Opis algorytmu}
Algorytm 2-opt jest algorytmem optymalizującym i wymaga nie tylko macierzy sąsiedztwa grafu ale także pewnego cyklu Hamiltona tego grafu. Wierzchołki grafu będą miały przyporządkowane położenie na osi X-Y, a koszt krawędzi odpowiadał odległości pomiędzy nimi. Klasyczne algorytmy realizujące problem komiwojażera nie uwzględniają istnienia w grafie krawędzi jednokierunkowych, więc zostaną one zasymulowane poprzez zwiększenie kosztu odpowiednich krawędzi o pewien współczynnik. \\


\subsection{Realizacja}

Algorytm 2-OPT [2] wykorzystuje znany cykl Hamiltona jako punkt wyjścia. Algorytm (zilustrowany pseudokodem na listingu 1) dokonuje zmian w najlepszym znanym cyklu Hamiltona poszukując cyklu o mniejszym koszcie całkowitym. Jeżeli taki cykl zostanie znaleziony, to zastępuje aktualne rozwiązanie. Algorytm kończy się, kiedy nie istnieje zmiana, która mogłaby skrócić cykl. Zmiana dokonywana przez algorytm 2-opt polega na: podziale cyklu na 3 części: początek, środek oraz koniec, odwróceniu kolejność wierzchołków w części środkowej i ponownym połączeniu cyklu. Operacja zamiany przedstawiona jest pseudokodem z listingu 2. \\


\begin{lstlisting}[caption={Główna część algorytmu}]

	2opt( droga_wejsciowa, lista_kosztow_krawedzi )
	{
		
		aktualna_droga = droga_wejsciowa
		aktualna_dlugosc = zmierz_dlugosc_drogi(aktualna_droga)
	
		do{
			poprzednia_dlugosc = aktualna dlugosc

			for (i = 0; i < liczba_wierzcholkow-1; i++) {
				for (j = i+1; j < liczba_wierzcholkow; k++) {
					nowa_droga = zamien( aktualna_droga, i, k )
					nowa_dlugosc = zmierz_dlugosc_drogi( nowa_droga )
					if( nowa_dlugosc < aktualna_dlugosc ){
						aktualna_droga = nowa_droga
						aktualna_dlugosc = nowa_dlugosc				
					}				
				}
			}
		}while( poprzednia_dlugosc > aktualna_dlugosc )
		
		zwroc [ aktualna_droga, aktualna_dlugosc ]
	}

\end{lstlisting}

\begin{lstlisting}[caption={Funkcja modyfikująca aktualną ścieżkę}]

	zamien( droga, a, b )
	{
		poczatek = droga[ 0:a-1 ]
		srodek = droga[ a:b-1]
		koniec = droga[ b: liczbawierzcholkow-1 ]
		srodek = odwroc_kolejnosc( srodek )
		nowa_droga = [ poczatek, srodek, koniec ]
		
		zwroc nowa_droga
	}

\end{lstlisting}


Funkcja zmierz\_dlugosc\_drogi będzie zwracać dlugość drogi. Drogi jednokierunkowe będą symulowane poprzez nadanie bardzo dużego współczynnika. \\

Współrzędne wierzchołków będą generowane losowo z pewnego zakresu i zapisywane w tablica\_wierzcholkow. Wylosowana zostanie lista połączeń jednokierunkowych oraz kierunek połączenia. Koszty połączeń, zapisane w tablicy jakosc\_drogi. Zwiększenie kosztu połączenia dla dróg jednokierunkowych realizowane będzie przez funkcję wprowadz\_kierunek.

Współczynnik drogi jednokierunkowej będzie przedmiotem naszego badania. \\

\begin{itemize}
\item tablica\_wierzcholkow[wierzcholek]=[polożenie\_X, położenie\_Y] - tablica przechowująca współrzędne wierzchołków.
\item jakosc\_drogi[wierzcholek1][wierzcholek2][kierunek] = [jakosc\_drogi] - jakość drogi pomiędzy wierzchołkiem1 a wierzchołkiem2 w jednym z dwóch kierunków
\item drogi\_jednokierunkowe[nr] = [wierzcholek1, wierzcholek2, kierunek] - lista dróg jednokierunkowych. Wartości tabeli zawierają parę wierzchołków oraz kierunek połączenia.
\item losoj\_polozenie(k) -  zwraca losowe wartości położenia w przestrzeni X-Y
\item losuj\_jakosc\_drogi( k) -zwraca losową tablicę opisującą jakość połączenia pomiędzy dwoma punktami w obu kierunkach
\item losuj\_drogi\_jednokierunkowe(k) - zwraca losową tablice dróg jednokierunkowych
\end{itemize}

\begin{lstlisting}[caption={Funkcja generujaca dane wejsiowe}]

	generuj_drogi( liczba_wierzcholkow, liczba_drog_jednokierunkowych 	)
	{	
		# stworz tablice zawierajaca wspolrzedne wierzcholkow w przestrzeni X-Y
		tablica_wierzcholkow = losuj_polozenie(liczba_wiercholkow)

		
		# wylosuj zbior par wierzcholkow polaczonych droga jednokierunkowa
		drogi_jednokierunkowe = losuj_drogi_jednokierunkowe(liczba_drog_jednokierunkowych)

		
		zwroc [ tablica_wierzcholkow, jakosc_drogi, drogi_jednokierunkowe ]
	}
		

\end{lstlisting}

\newpage
\begin{lstlisting}[caption={Funkcja wprowadzająca koszt połączeń jednokierunkowych}]

	wprowadz_kierunek( jakosc_drogi, drogi_jednokierunkowe,
					wspolczynnik_drogi_jednokierunkowej )
	{	

		#zwieksz koszt polaczen droga jednokierunkowa
		for( i=0; i< liczba_drog_jednokierunkowych; i++ )
		{
			# dla kazdego polaczenia jednokierunkowego
			# nalezy zwiekszyc wage w jednym kierunku
			jakosc_drogi[ drogi_jednokierunkowe[wierzcholek1] ]
						[ drogi_jednokierunkowe[wierzcholek2] ]
						[ drogi_jednokierunkowe[kierunek] ] 
							*= wspolczynnik_drogi_jednokierunkowej
		}		
		
		zwroc jakosc_drogi
	}
		

\end{lstlisting}


Generacja drogi wejściowej dla algorytmu 2-opt zostanie zrealizowana przy pomocy algorytmu najbliższego sąsiada. 

Algorytm najbliższego sąsiada polega na odwiedzeniu, począwszy od wybranego wierzchołka, wierzchołka znajdującego się najbliżej wierzchołka ostatnio odwiedzonego. \\


\begin{lstlisting}[caption={Algorytm najbliższego sąsiada}]

	najblizysz_sasiad(tablica_wierzcholkow, tablica_rozwiazan)
	{
		aktualny_wierzcholek = losuj_wierzcholek(tablica_wierzcholkow)
		oznacz_jako_odwiedzony(tablica_wierzcholkow, aktualny_wierzcholek)
		
		while(liczba_nieodwiedzonych_wiezcholkow(tablica_wierzcholkow))
		{
			nowy_wierzcholek = znajdz_najblizszy_wierzcholek(tablica_wierzcholkow, 
													aktualny_wierzcholek)
			dodaj(tablica_rozwiazan,nowy_wierzcholek)
			oznacz_jako_odwiedzony(tablica_wierzcholkow, nowy_wierzcholek)
			aktualny_wierzcholek = nowy_wierzcholek
		}
	}

\end{lstlisting}



Program testujący algorytm 2-opt powinien sprawdzić jaka musi być waga połączeń jednokierunkowych, aby algorytm nie wybierał połączeń "pod prąd". Program powinien wykonać się wiele razy na niezmiennym zbiorze wierzchołków i dróg jednokierunkowych. W kolejnych iteracjach koszt pokonania drogi jednokierunkowej będzie sukcesywnie zwiększany, aż do uzyskania wyniku nie zawierającego połączeń "pod prąd".
Program testujący musi przyjmować przygotowane wcześniej: zbiór wierzchołków, tablicę jakości połączeń oraz tablicę dróg jednokierunkowych. \\

W kolejnych iteracjach koszt połączeń będzie stopniowo zwiększany (na przykład o rząd wielkości). Liczba prób zostanie ustalona eksperymentalnie. Trudno jest przewidywać jaki współczynnik kosztu będzie niezbędny, aby zapobiec wyborowi dróg wiodących pod prąd. Algorytm 2-opt ma skłonność do znajdowania lokalnych minimów funkcji kosztu, dlatego spodziewamy się, że koszt pojedynczego połączenia jednokierunkowego będzie musiał być porównywalny z kosztem pokonania całej drogi. \\

Wyniki działania algorytmu dla różnych wartości współczynnika zostaną zebrane oraz podsumowane. Wykreślone zostaną zależności liczby kroków pod prąd od liczby połączeń jednokierunkowych oraz od współczynnika drogi jednokierunkowej. Dokonamy sprawdzenia w jakim stopniu wyniki są losowe poprzez przebadanie wielu grafów o tych samych parametrach. \\

\newpage
\begin{lstlisting}[caption={Funkcja testująca algorytm}]

		[ zbior_wierzcholkow, 
		jakosc_drogi, 
		drogi_jednokierunkowe ] = 
				generuj_drogi( liczba_wierzcholkow, 
						liczba_drog_jednokierunkowych )
		
		droga_startowa = nablizszy_sasiad( zbior_wierzcholkow )
		
		koszt = 1;
		for( i= 0; i< 100000; i++ )
		{
			jakosc_drogi[i] = wprowadz_kierunek( jakosc_drogi, drogi_jednokierunkowe,
					koszt )
			
			wynik[i] = 2opt( droga_startowa, jakosc_drogi )
		}
		
		podsumowanie( wynik )

\end{lstlisting}

\section{Sprawozdanie 3}

Sprawozdanie 3 składa się z następujących zagadnień: \\

\begin{itemize}

	\item Generacja danych testowych \ref{ss_generacja} - losowane współrzędnych wierzchołków grafu w przestrzeni X-Y oraz listy połączeń jednokierunkowych. Krótki opis tego kroku znajduje się w sekcji.
	\item Testów algorytmu \ref{ss_testy} - uruchomienie algorytmu 2-opt na różnych grafach z różnymi wartościami współczynnika kosztu drogi jednokierunkowej.
	\item Prezentacja oraz omówienie wyników \ref{ss_wyniki} - zaprezentowane zostały znalezione zależności.
	\item Wnioski \ref{ss_wnioski} - ostatnia część sprawozdania zawiera interpretację wyników. 
	\end{itemize}

\subsection{Generacja danych testowych}
\label{ss_generacja}

Głównym celem prezentowanego projektu była identyfikacja warunków, w których wybrany algorytm rozwiązujący problem komiwojażera w obecności ulic jednokierunkowych wybiera rozwiązanie zawierające odcinki wiodące pod prąd. \\

Algorytm 2-opt działa na grafie nieskierowanym, w którym wszystkie pary wierzchołków są połączone drogą o pewnym koszcie. Na potrzeby naszego projektu, zakładamy że każdy wierzchołek ma przyporządkowane położenie w przestrzeni X-Y, a koszt drogi jest równy odległości pomiędzy wierzchołkami. Zgodnie z treścią zadania niektóre drogi muszą być jednokierunkowe. 

Ponieważ nie chcemy modyfikować samego algorytmu, znacząco zwiększamy koszt drogi w kierunku "pod prad". Skoro wszystkie wierzchołki są połączone ze wszystkimi innymi, to musimy pamiętać, że jeżeli droga z jednego wierzchołka do drugiego jest zabroniona, to droga w przeciwną stronę musi być dozwolona. \\


Musimy również pamiętać, że zgodnie z treścią zadania interesujące są jedynie grafy Hamiltonowskie. Możliwość generacji całkowicie losowych grafów oraz zbiorów ulic jednokierunkowych została odrzucona, ponieważ konieczne byłoby sprawdzenie czy wylosowany graf posiada dozwolone rozwiązanie. Jedyną metodą pozwalającą sprawdzić, czy dowolny graf posiada cykl Hamiltona (którą udało nam się znaleźć) jest sprawdzenie wszystkich możliwych cykli, co jest problemem o ogromnej złożoności obliczeniowej.

Zdecydowaliśmy zawsze generować graf w którym żadna z dróg składających się na cykl 0->1->2-> ... -> n-1 -> 0 nie wiedzie pod prąd. Rozwiązanie jest proste w implementacji, ponieważ wymaga jedynie usunięcia odpowiednich dróg ze zbioru, z którego losowane są drogi pod prąd. Nie znaleźliśmy powodu, dla którego taki cykl miałoby wpłynąć na wynik testu. \\

Pierwotnie zakładaliśmy losowanie par wierzchołków, pomiędzy którymi droga będzie zabroniona (zwiększony koszt), ale okazało się to bardzo nieefektywne obliczeniowo. Po wylosowaniu nowej pary należało sprawdzić czy taka para (lub w przeciwnym kierunku) nie została wylosowana wcześniej oraz czy nie wchodzi ona w skład założonego poprawnego cyklu. Przy dużej liczbie dróg zabronionych takie rozwiązanie okazało się niezwykle wolne. \\

Znacznie szybsze okazało się wygenerowanie listy wszystkich możliwych kombinacji par liczb całkowitych z przedziału [0, liczba\_wierzcholkow-1], wprowadzenie losowego kierunku, usunięcie par wchodzących w skład cyklu referencyjnego i wylosowanie zadanej liczby dróg jednokierunkowych. Wprowadzenie kierunku było konieczne, ponieważ funkcja biblioteczna generowała pary w taki sposób, że pierwsza liczba z pary była zawsze mniejsza. \\

Grafy testowe mogą być generowane z różną liczbą wierzchołków oraz dróg jednokierunkowych. Lista zawierająca współrzędne wierzchołków w przestrzeni X-Y (każda ze współrzędnych jest z zakresu [0;1]) oraz lista zabronionych dróg w grafie zapisywane są do pliku.

Wygenerowane zostało po 50 grafów dla każdej z kombinacji:
\begin{itemize}
\item wierzchołki: 5, 10, 20, 50 oraz 100
\item drogi jednokierunkowe: 0\%, 10\%, 20\%, 30\%, 40\%, 50\%, 60\%, 70\%, 80\%, 90\% wszystkich dróg w grafie
\end{itemize}
%Ponadto, aby możliwe było wiarygodne porównanie skuteczności algorytmu 2-opt dla grafów o różnej liczbie wierzchołków, konieczne było generowanie liczby dróg jednokierunkowych będącej znaną częścią wszystkich dróg możliwych. Oczywiste jest, że 10 odcinków jednokierunkowych będzie większym utrudnieniem dla algorytmu w grafie zawierającym 10 wierzchołków niż w grafie zawierającym 100 wierzchołków. 
%
%Oba powyższe problemy udało się rozwiązać. Generujemy listę wszystkich możliwych kombinacji par liczb całkowitych z przedziału [0, liczba\_wierzcholkow-1] i wybieramy z nich od 0 do 90\% par (z krokiem 10\%). Otrzymane pary są zawsze rosnące np dla 3 wierzchołków otrzymaliśmy: [ [0,1], [0,2], [0,3], [1,2], [1,3], [2,3] ].



\subsection{Testy algorytmu}
\label{ss_testy}

Testy algorytmu rozpoczynają się od wczytania z pliku list wierzchołków oraz dróg jednokierunkowych. Tworzona jest macierz sąsiedztwa zawierająca koszt dróg odpowiadający odległości pomiędzy wierzchołkami, a następnie zwiększana o współczynnik drogi jednokierunkowej.

Tablica sąsiedztwa wykorzystywana jest przez funkcję tworzącą cykl Hamiltona na podstawie algorytmu najbliższego sąsiada. Ten cykl optymalizowany jest przez algorytm 2-opt. \\

Test powtarzany jest dla każdego z 50 grafów, w każdej z kombinacji parametrów \ref{ss_generacja}, dla współczynnika kosztu o wartościach: 1.5, 2, 5, 10, 100, 1000, 10000. \\

Wykonanie wszystkich testów zajmuje około 8 godzin, więc aby nie trzeba było ich powtarzać, wyniki każdego z nich zapisywane są do pliku. \\

Należy zwrócić uwagę, że liczby dróg jednokierunkowych różnią się w zależności od liczby wierzchołków. Zachowana jest za to proporcja liczby dróg jednokierunkowych do wszystkich dróg w grafie. 

Wydaje się oczywiste, że 10 odcinków jednokierunkowych będzie większym utrudnieniem dla algorytmu w grafie zawierającym 10 wierzchołków (45 dróg) niż w grafie zawierającym 100 wierzchołków (4950 dróg). 


\subsection{Wyniki}
\label{ss_wyniki}

\subsubsection{Odsetek dróg jednokierunkowych w grafie}
Najbardziej oczywistym testem wydawało się sprawdzenie skuteczności algorytmu w zależności od ilości dróg jednokierunkowych.

\begin{figure}
\includegraphics{"../images/zleodc_njedn_w2"}
\includegraphics{"../images/zleodc_njedn_w10000"}
\caption{Zależność liczby odcinków pod prąd (w stosunku do długości cyklu) od odsetka liczby dróg jednokierunkowych w grafie.}
\label{fig_drogi_jednokier}
\end{figure}
Na wykresie \ref{fig_drogi_jednokier} widać, że im więcej jest dróg jednokierunkowych, tym częściej algorytm wybiera drogę pod prąd. 

Zaskakująca może być wyższy odsetek zabronionych dróg dla grafów o małej liczbie wierzchołków. 

Zależność została zaprezentowana dla współczynnika drogi jednokierunkowej równego 2 oraz 10000. Przy małym współczynniku liczba dróg pod prąd rośnie prawie liniowo. Współczynnik jest za mały, żeby istotnie wpłynął na działanie algorytmu. Przy dużym współczynniku algorytm unika dróg pod prąd. \\

\begin{figure}
\includegraphics{"../images/zlecykl_njedn_w2"}
\includegraphics{"../images/zlecykl_njedn_w10000"}
\caption{Zależność odsetku rozwiązań dla których rozwiązanie zawiera drogi pod prąd od odsetka liczby dróg jednokierunkowych w grafie.}
\label{fig_cykle_jednokier}
\end{figure}

Zastanawiający wynik dla grafów o małej liczbie wierzchołków skłonił nas do sprawdzenia jak wiele rozwiązań zawiera przynajmniej jeden odcinek pokonany pod prąd. Zależność zilustrowana na wykresie \ref{fig_cykle_jednokier}.

Wydaje się, że ta zależność jest bardziej adekwatna do tematu projektu, ponieważ pokazuje, przy jakim zagęszczeniu dróg jednokierunkowych można spodziewać się rozwiązań bezbłędnych.

Na wykresie \ref{fig_cykle_jednokier} jeszcze wyraźniej widać, że zbyt mały współczynnik drogi jednokierunkowej nie wpływa na działanie algorytmu. Dla współczynnika równego 2, liczba niedozwolonych rozwiązań rośnie bardzo szybko ponieważ wybranie takie rozwiązania jest bardziej prawdopodobne.

\subsubsection{Współczynnik drogi jednokierunkowej}

Poprzednie wykresy pokazują w pewnym stopniu wpływ wartości współczynnika na wyniki, ale dokładniejsze zbadanie tej zależności było konieczne.

Wykresy \ref{fig_odc_wsp} oraz \ref{fig_cykle_wsp} sugerują, że wartość współczynnika ma niewielkie znaczenie dla wartości wyższych niż 10.

\begin{figure}
\includegraphics{"../images/zleodc_wsp_j2"}
\includegraphics{"../images/zleodc_wsp_j5"}
\caption{Zależność stosunku dróg pokonanych pod prąd do długości cyklu od wartości współczynnika kosztu.}
\label{fig_odc_wsp}
\end{figure}

\begin{figure}
\includegraphics{"../images/zlecykle_wsp_j2"}
\includegraphics{"../images/zlecykle_wsp_j5"}
\caption{Zależność odsetka cykli zawierających niedozwolone rozwiązania od wartości współczynnika kosztu.}
\label{fig_cykle_wsp}
\end{figure}

\subsubsection{Badanie warunków generujących zabronione rozwiązania}

Na koniec zdecydowaliśmy się zbadać, dlaczego algorytm wybiera niedozwolone rozwiązania. Wiemy, że dozwolony cykl istnieje, ale jego koszt jest losowy. Postanowiliśmy sprawdzić jaki jest stosunek długości znanego dozwolonego cyklu (może istnieć inny cykl dozwolony) oraz cyklu wybranego przez badany algorytm. \\

Wykres \ref{fig_krotsze_wsp} pokazuje, że dla małych współczynników drogi jednokierunkowej algorytm zwykle znajduje rozwiązanie o mniejszym koszcie niż rozwiązanie referencyjne. Potwierdza to, że współczynniki poniżej 10 są zbyt małe. Dla większych grafów wszystkie rozwiązania są krótsze niż referencyjne (mimo bardzo dużego współczynnika).

Trudno jest określić jakąś zależność na podstawie \ref{fig_krotsze_jednokier}. Może to sugerować, że dla bardzo wielu dróg jednokierunkowych algorytm nie jest w stanie znaleźć dozwolonego rozwiązania.


\begin{figure}
\includegraphics{"../images/krotsze_jednokier"}
\caption{Odsetek niedozwolonych cykli, krótszych niż referencyjny w zależności od odsetka dróg jednokierunkowych}
\label{fig_krotsze_jednokier}
\end{figure}

\begin{figure}
\includegraphics{"../images/krotsze_wsp"}
\caption{Odsetek niedozwolonych cykli krótszych niż referencyjny w zależności od współczynnika kosztu drogi jednokierunkowej}
\label{fig_krotsze_wsp}
\end{figure}

\subsection{Wnioski}
\label{ss_wnioski} 

Analiza wyników symulacji wskazuje, że zaimplementowana metoda symulacji dróg jednokierunkowych działa dobrze dla grafów, w których odsetek takich dróg jest mniejszy niż 20\%-30\%. \\

Wartość współczynnika kosztu drogi jednokierunkowej ma duże znaczenie, ale tylko do pewnego momentu. Przy naszych założeniach współczynniki powyżej 10 dają bardzo zbliżone wyniki. Należy zwrócić uwagę, że maksymalny koszt drogi pomiędzy punktami położonymi na płaszczyźnie o wymiarach 1x1 to 1.41. Spekulacyjnie określony współczynnik jest więc większy mniej więcej o rząd wielkości. \\

Zauważyliśmy, że w wielu przypadkach cykl znaleziony przez algorytm ma mniejszą długość niż cykl dozwolony. Przypuszczamy, że jest to spowodowane przez mnożenie kosztu drogi jednokierunkowej przez współczynnik. Takie rozwiązanie ma niewielki wpływ na koszt bardzo krótkich odcinków. Algorytm 2-opt wybiera wiele krótkich, niedozwolonych odcinków zamiast dłuższego dozwolonego.

Możliwe, że lepszym rozwiązaniem byłoby zastępowanie kosztu odcinka zabronionego przez stałą, dużą wartość. Wtedy niezależnie od odległości na płaszczyźnie, przejście pod prąd znacząco podnosiło by koszt rozwiązania.

Niestety sprawdzenie powyższej teorii wymagałoby ponownego przeprowadzenia testów i opóźnienia złożenia sprawozdania o kolejny dzień.



\section{Bibliografia}


\begin{enumerate}
\item Byung-In Kim, Jae-Ik Shim, Min Zhang, “Comparison of TSP Algorithms” Project for Models in Facilities Planning and Materials Handling, December 1998. %https://pja.mykhi.org/4sem/NAI/rozne/Comparison%20of%20TSP%20Algorithms/Comparison%20of%20TSP%20Algorithms.PDF
\item "A method for solving traveling salesman problems." - G. A. Croes
\end{enumerate}

\end{document}